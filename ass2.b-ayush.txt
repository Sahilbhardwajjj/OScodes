//parent code
// main_process.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

// Ascending order bubble sort
void sort_ascending(int *arr, int size) {
    int temp;
    for (int pass = 0; pass < size - 1; pass++) {
        for (int i = 0; i < size - pass - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
            }
        }
    }

    printf("\n[Parent] Sorted array in ascending order:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <child_program_path> <num1> <num2> ...\n", argv[0]);
        return 1;
    }

    int count = argc - 2;
    int values[count];

    // Convert input strings to integers
    for (int i = 0; i < count; i++) {
        values[i] = atoi(argv[i + 2]);
    }

    // Sort array in ascending order
    sort_ascending(values, count);

    // Prepare arguments for execve
    char *child_args[count + 2];
    child_args[0] = argv[1];  // path to child program

    for (int i = 0; i < count; i++) {
        child_args[i + 1] = malloc(12); // Enough to hold int as string
        sprintf(child_args[i + 1], "%d", values[i]);
    }
    child_args[count + 1] = NULL;

    // Create child process
    pid_t pid = fork();

    if (pid == 0) {
        // Child
        printf("\n[Child] PID: %d | PPID: %d\n", getpid(), getppid());
        execve(argv[1], child_args, NULL);
        perror("execve failed");
        exit(EXIT_FAILURE);
    } else if (pid > 0) {
        // Parent
        wait(NULL);
        printf("\n[Parent] Child finished. PID: %d\n", pid);
    } else {
        perror("fork failed");
        return 1;
    }

    // Clean up memory
    for (int i = 1; i <= count; i++) {
        free(child_args[i]);
    }

    return 0;
}
// Second code(child)

// child_process.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Descending order bubble sort
void sort_descending(int *arr, int size) {
    int temp;
    for (int pass = 0; pass < size - 1; pass++) {
        for (int i = 0; i < size - pass - 1; i++) {
            if (arr[i] < arr[i + 1]) {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
            }
        }
    }

    printf("\n[Child] Sorted array in descending order:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <sorted_numbers>\n", argv[0]);
        return 1;
    }

    int size = argc - 1;
    int numbers[size];

    for (int i = 0; i < size; i++) {
        numbers[i] = atoi(argv[i + 1]);
    }

    printf("\n[Child] Executing child process with PID: %d\n", getpid());

    sort_descending(numbers, size);

    return 0;
}


















// Output
student@ubuntu:~/Ayush_I3104$ gcc main_process.c -o main_proc
student@ubuntu:~/Ayush_I3104$ gcc binary_search_program.c -o search_prog
student@ubuntu:~/Ayush_I3104$ ./main_proc ./search_prog 34 12 9 78 56

[Parent] Sorted array in ascending order:
9 12 34 56 78 

[Child] PID: 4247 | PPID: 4246

[Child] Executing child process with PID: 4247

[Child] Sorted array in descending order:
78 56 34 12 9 

[Parent] Child finished. PID: 4247


















this program demonstrates *interprocess communication using fork() and execve()*,
where the parent process sorts numbers in ascending order and the child process
(a separate executable file) sorts the same numbers in descending order.

important terms:
fork() – creates a new process. the parent continues execution, and the child runs as a separate process.
execve() – replaces the current process image with a new program (used here to execute the child program).
wait() – makes the parent wait for the child to finish execution.
atoi() – converts a string to an integer.
malloc() – dynamically allocates memory to store command-line arguments as strings.
free() – releases the dynamically allocated memory.
getpid() – returns the process id of the current process.
getppid() – returns the process id of the parent process.
argc / argv – command-line arguments count and list respectively.
sort_ascending() – sorts numbers in ascending order (used by parent).
sort_descending() – sorts numbers in descending order (used by child).
child_args – array used to pass sorted numbers from parent to child process through execve().

explanation of first code (parent process):

1.⁠ ⁠the parent process takes command-line input: the child program’s path and a list of numbers.
2.⁠ ⁠it converts the numbers from string to integer and sorts them in ascending order using sort_ascending().
3.⁠ ⁠it prepares a new argument list (child_args) that includes the sorted numbers, which will be passed to the child program.
4.⁠ ⁠fork() is called – it creates a child process.

   * in the *child process*, execve() is executed, which runs the separate child program and passes the sorted list to it.
   * in the *parent process*, wait() ensures that the parent waits for the child to finish execution.
5.⁠ ⁠after the child finishes, the parent displays the child’s pid and cleans up dynamically allocated memory.

explanation of second code (child process):

1.⁠ ⁠this separate executable (child_process.c) receives the sorted numbers as command-line arguments.
2.⁠ ⁠it converts them into integers and prints its pid.
3.⁠ ⁠it calls sort_descending() to sort the numbers in descending order and displays the result.
short explanation – the parent process sorts the numbers in ascending order and passes them to a separate 
executable child process using execve(). the child process sorts the same numbers in descending order. this
demonstrates process creation, parent-child synchronization using fork() and wait(), and program replacement
using execve().
